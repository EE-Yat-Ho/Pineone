반응형 프로그래밍 :
데이터 플로우와 상태변경을 전파한다는 생각에 근간을 둔 프로그래밍
반응형의 특징 - 1. 밖에서 안으로, 2. 자극이 있어야 반응하는 수동성.

관찰자를 통해 데이터의 흐름을 관찰하여 데이터가 변경되면 함수나 수식으 ㄹ업데이트~~~

그래서 왜쓰는거죠?
인터넷 환경이 발달함에 따라 트래픽이 많아지고 무거워지고
그에따라 멀티코어 프로세스로 처리하는 프로그래밍이 중요해졌습니다
그래서 비동기적으로 한번에 처리하는 반응형 프로그래밍을 써야한다~

기존의 절차적 프로그래밍은 이를 하기 어려워서 반응형 프로그래밍으 ㄹ써야함
반응형 프로그램 예 ) 엑셀. 셀 하나의 변경을 감지해서 관련된 셀 들이 바뀌는겅ㅇㅇㅇㅇ


리엑티브 익스텐션 (Rx):
= 오픈소스 프로젝뜨
RxSwift = 스위프트에서 Rx를 쓰게하는 라이브러리
옵저버패턴 + 반복자패턴 + 함수형프로그래밍의 조합이다ㅏㅏ
함수형 프로그래밍 : 간단히, 자료처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍
순수함수만을 작성하여 프로그래밍하는 방식(사이드 이펙트 없는거)

사실 스위프트만으로 api 로 비동기처리가 가능하긴함
그러나 프로젝트 규모가 커질수록 코드양 많아지고 가독성 떨어쥠
Rx를 사용한다면 일관적이고 쉽게 구현이 가능하댜

옵저버는 옵저버블을 구독한다~
ㅡㅡㅡ    ㅡㅡㅡㅡ    ㅡㅡ 중요중요
관찰자  관찰할수있는 구독

옵저버는 옵저버블이 방출하는 모든 아이템에 대해 반응한댜
옵저버블 = 시퀀스 = 스트림 = 옵저버블시퀀스

이런 비동적으로 아이템을 생성하는 과정을 Emit이라고함
.just(1) = 옵저버블이 가진 연산자랍니당
하나의 elemet를 방출하는 옵저버블이라는 뜻
of : 여러개를 배출하는 연산자
from : 배열을 넣어주고 배열의 요소들을 방출하는 연산자

옵저버블은 3가지 행동규칙이 있음 넥스트 에러 컴플리트
넥스트 : 연속된 값들을 배출
에러 : 에러발생시 에러를 배출하고 멈춤
컴플리트 : 넥스트가 잘 끝났을때 컴플리트하면서 종료

오우 공식문서에 마블 다이어그램 중요중요
옵저버블에 대한 시간, 데이터의 흐름을 표현한것

오퍼레이터 라고 있는데 뭐
넘어온 아이템을 필터링, 변환, 조합 등 전처리 하기 위한 것들이라고 합니당 종류가 겁나 많네
심지어 에러 발생시 재시도하는 것들도 있뜸 와우씓

오퍼레이터 : 옵저버블 상에서 작동하고 옵저버블을 반환한다하고 합니당
그래서 체이닝이 가능함 와우우우우우우우
observable.operator1().operator2()…. 아 저번에 본게 이거구만 ㅎㄷ

옵저버블 자체는 시퀀스를 정의할뿐암거도안함

서브스크립은 옵저버블의 알림가ㅗ 방출ㅇ ㅔ따라 동착함
서브스크립 연산자를 통ㅎㅇㄴㅁㄹㅁㄴ

서브젝트 = 옵저버 + 옵저버블
실시간으로 옵저버블에 새로운 값을 추가하고 서브스크립트에게 방출 ㅇㅅㅇ 먼소리야
서브젝트에는 4가지 종류가 존재함으음…..
아 그그 
어싱크 서브젝트 뭐라하셧지

behavior서브젝트 가장 최근에 방출된게 없으면 기본값 방ㅇ출 후 서브스크립트
있으면 가장 최근에 방출한걸 방출하고 서브스크립트

publishSubject 상관없이 그냥 구독한 다음 발생하는거만 방출

ReplaySubject 여태 방출한 거 싹다 방출해주고 구독(지난거 몇개 해줄건지 지정가능)(최근검색 리스트 그런거 ㅇㅅㅇ)

콜드 핫 옵저버블 오 ㅋㅋㅋㅋ ㅎㅇ
항목들을 배출하는 성격에따라 콜드와 핫으로 나눔 옵저버블을 ㅇㅇ
여태 본건 전부 콜드 옵저버블이였뜸!
핫의 콜드와의 가장 큰 차이는 ?먼데 ㅁㄹ 관찰자 없어도 자원 사용하는거?

저스트, 오브 그러기전에 크리에이트가 가장 기본이다아아앗
“본인도 콜드와 핫 설명할 수준은 아닌거같고 넘어가세요” 와,,ㄸㄸㄷ 콜드랑 핫 넘어가버림 ㅠㅜ

네가지 서브젝트 외에도 릴레이라는게 존재함 relay
behavior서브젝트를 래핑한 서브젝트라고 합니다 와우
UI 컴퍼넌트에서 바인딩이나 작업할 때 그 안에 쓰이는 방법이라고 합니당
릴레이의 가장 큰 특징 : 에러 이벤트를 발생하지 않음!! 뭐고이겓ㄸㄸㄷ
아 유아이가 좀 틀려도 계속 작동해야하니까

스케쥴러 : 옵저버블을 사용할 때 쓰레드를 따로 정해주지않으면 구독을 시작한 쓰레드에서 해당 작업이 처리됨!!
다른 쓰레드에서 작업하고 싶다면 스케쥴러를 사용해야함
Rx정의한 것으로 작업하는 쓰레드를 정해줄수잇는 클래스
스케쥴러 종류 1 시리얼 : 하나의 작업
2. 컨커런트 : 동시 여러 작업
3. 흐으음

스위프트에ㅓㅔ 제공하는 뭐 시리얼큐, 디스패치큐 이런거에서 꺼내오는 스케쥴러들? 이런거도 있다하심

서브스크라이브온 이라는 연산자로 스케쥴러를 지정해주는 방식 ( 쓰레드를 바꾼닷 )
서브스크라이브온 : 생성될때 즉, 젤 처음에 스레드 설정을 해줌
옵저브온 : 자기가 삽입된 곳부터 스레드 설정을 함

서버에서 데이터를 받아오는 부분은 백그라운드 스레드를 사용한답니다 ^^
데이터를 받아오고 유아이에 뿌려줄때는 메인으로(스위프트에서 유아이는 메인에서 업데이트 해야한다는 규치깅 ㅣㅇㅆ기때문)
해야해서, 옵저브온으로 메인스레드로 도중에 바꾸는 등의 기능이 필요함

RxCocoa 
RxSwift는 UIKit에 대한 정보가 없어서 이를 위한 UIKiat과 Cocoa 프레임워크 기반 모든 클래스를 가진 라이브러리
아따 잘만들었누
사실상 UI는 빠질 수 없기 때문에 두개를 동반자 라이브러리라고 함

바인딩: 데이터를 UI에 표시하는 것
Data 생산자 [ 옵저버블 ]  ——> Data 소비자 [ UI 요소들 ]
반대방향으로의 데이터 전달은 불가능

바인더 : UI바인딩에 사용되는 특별한 옵저버
에러 이벤트를 받지않는게 큰 특징 ㅇㅇ UI 종특이쥐
배동연 선임님 : 컴플리트는 왜받누 에러처럼 종료되는데!! -> 받는건 맞음 근데 그 이유는 잘 모르겠눼.. 걍 더이상 변화가 없을 경웅ㅇㅇㅇㅇ
 
 RxCocoa에서는 subscribe()를 bind(to:)라고 호출함
A.bind(to: B)
A: 데이터 생산자, B : 데이터 소비자
A가 변경하면 B에 영향을 줌
바인드시 유아이에 바인드 할 경우 알아서 메인스레드로 지정이됨 ㅇㅇ 유아이는 메인만 되자누