## 20200917 오늘 한 일
### 1. 시험
프로토콜  
특정 역할을 하기위한 메소드, 프로퍼티, 기타 요구사항의 청사진.  
프로퍼티는 저장, 연산은 정할 수 없고, 읽기 쓰기 여부는 정해짐.  
static 붙이면 타입 프로퍼티, 타입 메소드  
mutating 붙이면 인스턴스의 저장 프로퍼티를 변환시키는 메소드라는 뜻  
optional 붙이면 구현 안해도 되는 메소드 라는 뜻. 다만 프로토콜에 objc 붙이고, 클래스에 NSObject 상속.  
프로토콜끼리 상속 가능  
그래서 옵셔널 같은게 있는데 프로토콜을 쓰는 이유는..? 대답못함  

익스텐션  
클래스, 구조체, 열거형에 새로운 기능을 추가.  
소스를 몰라도 타입 이름만 알면 추가가능함 와우.  
재정의 불가능. 오버로딩은 가능 ^^  
연산 프로퍼티, 메소드, 생성자, 서브스크립트, 프로토콜 등을 추가할 수 있음.  

클로저  
실행가능한 코드의 묶음  
함수는 클로저의 일종  
타입유추, 인자이름 생략 및 단축, 암시적 반환, 괄호 생략 등으로 축약 가능  
후행 클로저 지원  
일급시민으로 취급하기 때문에 인자, 반환값으로 사용하는 등 일반적인 변수처럼 사용 가능  

lazy
호출 직전에 메모리에 올라가는 변수.  
var만 가능  
인스턴스에 굳이 모든 프로퍼티를 사용하지 않아도 될 때 사용함.  
다중스레드에서 여러번 초기화될 가능성 있음.  

waek  
ARC를 통한 메모리 관리 중, 강한참조 순환을 막기위해 사용함.  

접근수준  
open : 다른 모듈에서 상속 가능  
public : 다른 모듈에서 사용 가능  
internal : 같은 모듈에서 사용 가능  
fileprivate : 같은 소스파일에서 사용 가능  
private :  같은 구현범위에서 사용 가능  

guard  
else 랑 같이 써서 false인 경우 else문 실행.  
else에는 상위 블록을 탈출하는 return, break 등이 쓰여야함.  

옵셔널 바인딩, 체이닝  
if let, if var.  이거 말고 guard랑 ?? 도 바인딩임..
변수를 확인하여, nil인 경우와 아닌 경우 구별  
오브젝트C와 호환성, 소스 가독성을 위해 사용  

escape  
클로저를 함수 인자로 넘겨줬을 때, 함수가 끝난 이후 그 클로저를 재사용해야 할 때 escape해줘야함.  

required  
자식이 꼭 재정의해야하는 메소드, 생성자  

클래스와 구조체  
클래스 : 참조 타입, 상속 가능  
구조체 : 값 타입, 상속 불가능  

mutating  
인스턴스의 프로퍼티를 변경하는 메소드라는 뜻  

is, as  
is : 타입 확인  
as : 타입 캐스팅, 컴파일 타임에 실행  
as? : 캐스팅 실패시 nil, 런타임에 실행  
as! : 캐스팅 실패시 오류, 런타임에 실행 ㅇㅎ; 이런촤이가.. 근데 뜻 생각해보면 그럴거같네ㅇㅈ

nil, null
두개 다르데요 ㅡㅡ
nil : 객체가 없다는 뜻. 객체 값이 0
null : C포인터가 없다는 뜻. 포인터의 주소값이 0.. 이라고 이해,..

제네릭  
타입의 일반화로 중복코드를 줄임  

프로퍼티  
저장 : 일반적인 변수  
연산 : set, get을 통해 저장 프로퍼티를 세팅, 반환하는 프로퍼티  
타입 : 인스턴스가 아닌 타입자체의 프로퍼티(C의 static constant와 비슷)  

서브스크립트  
인스턴스[값]에서 무슨 값을 반환 할지 정할 수 있음  

멤버와이즈 이니셜라이저  
구조체에서만 지원. 모든 저장프로퍼티에 초기값을 주는 자동으로 제공하는 생성자  

실패가능한 이니셜라이저  
init? 이런식으로 사용.  
return nil을 통해서 생성실패가 가능함  

모나드  
옵셔널이 모나드임  
타입을 인자로 받고,  
타입을 포장해서 반환하고,  
포장된 타입을 값 변경 후 재포장해서 내보내는 게 있어야함  
정확히 모르겠다 냥..  

final  
상속불가 클래스  
재정의 불가 메소드  

ARC  
강한 참조값을 자동으로 카운팅해서 0이면 메모리에서 조져버리는 좋은녀석  

where  
switch에서는 케이스에 조건을 추가함  
프로토콜의 익스텐션에서는 이 익스텐션이 어떤 프로토콜을 준수하는 타입에만 적용할 지 지정가능함  
말고 다양한 패턴에서 다양한 기능이 더 있음 와웅  

콜렉션형  
배열, 딕셔너리, 세트  
json은 딕셔너리랑 매칭이된다카심ㅇㅇ  

클로저의 벨류캡처, 래퍼런스 캡처  
~~~
func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
~~~
incrementer이 runningTotal은 변화하기 때문에 참조획득,  
amount는 그대로라서 값획득.   
Swift에서 알아서 캡쳐한다고함.  흠.....ㅇㅋㅇㅋ;  

GCD   
Grand Central Dispatch  
보기전에   

Dispatch Queues  
task 수행을 위한 도구  
비동기/동기식으로 임의의 코드 블록을 수행  
쓰레드의 거의 모든 기능과 비슷.  
쓰레드보다 사용하기 쉽고 효율적.  
항상 FIFO구조  
4가지 종류  

Serial : 한번에 하나의 task 실행. DQ의 고유 쓰레드에서 실행.   
특정 자원에 대한 액세스를 동기화하는데 사용.  
4개의 Serial 큐를 작성하여 4개의 task를 동시에 실행할 수 있음.  

Concurrent ( = global dispatch queue ) : 여러개의 task를 동시 실행.  
DQ의 고유 쓰레드에서 실행. 실행되는 task의 수는 가변적이며 시스템 조건에 따라 다름.  
사전에 정의된게 4개 있음  

Main dispatch queue : 앱의 메인쓰레드에서 task를 실행하는 전역 Serial큐.  
앱의 실행루프와 함께 작동하여, 다른 이벤트 소스의 실행과 얽힘. 앱의 주요 동기화 지점으로 사용됨.  

DQ의 쓰레드에 비한 장점  
모델의 단순화. 쓰레드 생성 및 관리 코드 생략가능. 시스템이 알아서 해쥼.  
쓰레드를 직접 작성한 경우보다 시스템이 task를 실행하는게 더 빠름.  
크리티컬 섹션 관리도 알아서 해줌; 와 안쓰고 어캐살아.  

오퍼레이션 큐  

오 쓰레드랑 거의 비슷한 내용인데? 이건 여기 적지말고 따로 정리하쟈  
근데 책에 안나오네 아쉽..  


## 20200917 내일 할 일
### 1. 재택 전에 비행기 예약 한거 때문에 30분 일찍 퇴근..잊지말기 ㅠ
### 2. 
