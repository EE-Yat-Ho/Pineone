## 20200909 오늘 한 일
### 1. Extension으로 addSubView 처리
배동연 선임님이 말씀하신거임!

### 2. AutoResizingMask 완성

### 3. intrinsic 완성

### 4. 발표준비
????? 다음주에 재택근무 하게되서 당장 내일 발표해야함........
오토 리사이징 뺴고
피피티 10장 내외로
상위 텍스트뷰, 콜렉션뷰 하나씩
피피티에 넣어서 소스 비교하는식
제약사항 사용하는 방법까지

1. 안녕하세요! AutoLayout 세미나를 맡게된 서비스플랫폼 사업본부의 박영호 전임입니다~
저보다 아는게 많으신 분들앞에서 이런 발표를 하는게 참 어색하지만
열심히 해보겠습니다 ㅎㅎ

2. 자 AutoLayout이 무엇일까요.
인터페이스 레이아웃 방법 3가지 중에 가장 최근에 나온. 가장 많이 사용하는 Layout 방법 입니다.
이 방법은, 뷰를 다른뷰들과의 상호관계, 제약사항을 이용하여 이 뷰의 위치와 크기를 동적으로 자동으로 계산해주는 아주 펀쿨섹한 방법입니다.

3. 뷰를 레이아웃 하는 방법은 3가지가 있습니다.
가장 처음 사용했던 프레임 Frame-Based Layout,
그 대안으로 나온 AutoResizingMask
그리고 완전히 새로운 패러다임으로 나온 AutoLayout 입니다.

4. 먼저 프레임 베이스드 레이아웃 입니다.
가장 처음 사용했으며,
뷰의 좌상단 점의 위치와, 넓이, 높이를 기반으로 뷰를 띄워줍니다.
단순히 그게 전부입니다.
때문에, 런타임에 뷰들의 구조가 변경되면, 영향을 받는 뷰들의 모든 프레임을 다시 계산했어야 했습니다.
또한, 가로모드 화면과 작은화면 큰화면 등 다양한 크기의 화면에 대응하는 뷰 구조 설계를 따로 했어야 했습니다.

5. iPad나 iPhone5가 나오면서 화면이 다양해지자
프레임 베이스드 레이아웃의 대안으로 애플이 제시한 것이 AutoResizingMask 입니다.
이것은 프레임으로 준 초기 위치와 부모 뷰와의 위치 관계를 가지고 제약을 자동으로 생성합니다.
부모 뷰의 프레임이 변경될 때, 하위 뷰의 프레임을 조절해주는 

3. 애플은 뷰에서 위치나 크기를 표현하기 위한 Constraint로 8가지를 정의해놓았습니다.
Top, Bottom, Leading, trailing, CenterY, CenterX, Height, Width가 그것들이며
이것들을 사용해서 동적으로 뷰들의 위치를 조정할 수 있습니다!


Baseline은 뭐죠?
Baseline은 현재 FirstBaseline으로 사용되며, 
텍스트를 가진 개체의 텍스트 상단시작위치를 뜻하는 특이한 친구입니다.

4.

Constraint
이런것들을 이용해서 모든 뷰의 크기과 위치를 동적으로 계산할 수 있게 됩니다.
왜 동적으로 계산할까요~? ~~~~ 맞습니다 한마디로 편해서입니다
동적으로 계산하지 않고 정적으로 계산하는. 예전의 방식이 있었습니다.

이것을 프레임 베이스드 레이아웃이라고 하며,
프레임. 즉 뷰의 좌상단 점의 위치와 넓이 높이를 모두 지정하는 방식이였습니다.
이 방식은 뷰가 런타임에 삽입, 삭제되는 경우 일일히 뷰의 위치를 재 설정해줘야 하고,
가로모드의 경우도 따로 만들어야하고,
작은화면, 중간화면, 큰화면.. 다양한 크기의 화면들에대해서도 모두 프레임 설정을 해줘야 했습니다 ㅠㅠ
매우매우매우 비효율적인 방식이란 말이죠

초기엔 그럭저럭 쓰다가 iPad와 iPhone 5가 나오면서부터 
화면의 크기가 매우 다양해지면서 이 방식은 버려지게 됩니다.

이에 애플은 프레임으로 주게된 초기위치를 기반으로 자동으로 Constraint를 주는 AutoResizingMask를 개발하게 됩니다.
하지만 Constraint를 자동으로 생성해주는 만큼, 같은 부모를 가진 자식들끼리의 관계만 표현 할 수 있었고
코드가 직관적이지 않으며,
뷰가 많아질 수록 자동으로 조정되는 방식이 개발자의 생각과 맞지 않을 수 도 있었습니다.

그래서 나온게 뭐냐! 바로 AutoLayout입니다!
제약사항을 기반으로 뷰들의 위치를 동적으로 조정하여
다양한 크기의 뷰에 대응할 수도, 런타임 중 뷰의 생성과 제거도 비교적 편하게 할 수 있게 되었습니다!
게다가 필요에 따라 멀리 떨어진 계층에 있는 뷰와의 제약사항도 추가할 수 있습니다.
또한 소스코드 또한 직관적으로 바뀌었습니다!
대박대박

이 AutoLayout의 제약사항이 바로 Constrait입니다~

이제 이 좋은 오토레이아웃의 제약사항을 어떻게 줄 수 있는지 보여드리겠습니다.

스토리보드, NSLayout, VisualFormat, 두개 혼합, Achor방식을 준비했으며
intrinsic 과 스냅킷은 추후에 하도록 하겠습니다? ^_^?

우선 화면에 보이는 화면은 제가 친구들과 만들고 있는 문제를 만들고 푸는 형식의 반복학습 어플이며, 객관식 문제를 만드는 화면입니다.
아직 디자인 완성 전이라서 구립니다 ㅎㅎ휴ㅠㅠㅠ
간단하게 상단의 라벨과 텍스트뷰 콜렉션뷰를 가지고 코드를 보며 각 방식을 비교하겠습니다.

1. 스토리보드 방식입니다.
우측 하단의 버튼을 눌러서 쇽쇽 설정해주면 됩니다 아주 간단하고 직관적이죠
하지만 한번 뻑나면 원인을 찾기가 너무힘들고 형상관리도 힘듭니다..

여기서 각 차원에서 최소 두개의 제약조건이 피료하다~말해야겐네

2. NSLayout 방식입니다.
파라미터 이건 이거고 저건 저거고 이렇게 하는겁니다
코드가 비교적 복잡하고 직관적이지 않다는 단점을 가지고 있습니당

3. VisualFormat 방식입니다
이런 이런방식으로 사용하며 한축은 이렇게 한번에 짜잔 와우씓!
NSLayout의 길고 복잡한 코드를 직관적으로 바꾸려고 나온 방식입니다
상당히 직관적인 소스를 확인할 수 있습니다. 
하지만 시각화에 치중한 나머지 이런이런 기능에 한계가 생겼습니다.

4. 때문에 VisaulFormat에서 지원하지 않는 부분을 NSLayout으로 대채하여 사용하기도 합니다

5. Anchor 방쉭
마침내 직관적이고 

activate(
  boxA.anchor.top.left,
  boxB.anchor.top.right,
  boxC.anchor.bottom.left,
  boxD.anchor.bottom.right
) 아니 이게 된다고?


https://stackoverflow.com/questions/25055248/auto-layoutconstraints-vs-auto-resizing-masksprings-struts

https://oleb.net/blog/2013/03/things-you-need-to-know-about-cocoa-autolayout/
1. 경험 법칙 : 각 차원에서 최소 두 개의 제약 조건
각 차원 (수직 및 수평)에서 각보기의 위치와 크기는 선행 공간, 크기 및 후행 공간의 세 가지 값으로 정의됩니다.선행 및 후행 공백은 뷰의 수퍼 뷰 또는 뷰 계층 구조의 형제와 관련하여 정의 할 수 있습니다. 일반적으로 레이아웃 제약 조건은 세 번째 값을 계산할 수 있도록 이러한 값 중 두 개를 수정해야합니다. 결과적으로 표준 뷰는 명확한 레이아웃을 위해 각 차원에 최소 두 개의 제약 조건이 필요합니다.

https://medium.com/flawless-app-stories/how-to-make-auto-layout-more-convenient-in-ios-df3b42fed37f



## 20200909 내일 할 일
### 1. 엥 벌써 목요일이네 주간보고서 쓰기;;
### 2. 발표 피피티, 대본 완성 및 잘하기!!!!!!
