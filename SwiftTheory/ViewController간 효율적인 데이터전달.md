# ViewController간 효율적인 데이터전달
## https://hyunable.github.io/2017/11/20/view-dataTrade/
### 화면전환시 Data 전달법 
// 음.. 프리페어, 세그, 네이게이션팝푸쉬 등 가장 쉬운방법들

### 직접전달 방식 (동기 방식)  
뷰 컨트롤러에 직접 값을 전달하는 방식으로 영속적으로 값을 저장할 필요가 없는 화면 전환에서 사용된다. ( 예: 테이블뷰 -> 디테일뷰 )  
전달 받는 쪽의 뷰컨트롤러가 전달 받을 값의 명세를 모두 파악하고, 대입할 변수를 미리 준비해두어야한다.

### 간접 전달 방식 (비동기 방식)
저장소를 이용하여 값을 전달하는 방식은 주로 지속적으로 값을 저장할 필요가 있는 화면 전환에서 사용된다. ( 예 : 로그인시 로그인 정보가 계속적으로 유지되어야 한다. 메모장 앱)  
받는쪽과 보내는 쪽 모두 저장소의 위치를 사전에 공유하고 있어야 한다.  
데이터가 도달하는 시간과 화면전환이 완료된 시점이 상이하므로 맞춰주어야 한다.  
값을 전달한다기 보다 , 값을 저장하고 그 저장된 값을 불러오는 행위이다.

### 직접전달 방식 순서
VC1 -> VC2 라고 가정한다.  

VC1 : VC2로 전달할 값을 준비한다.  
VC2 : 값을 대입받을 프로퍼티를 정의한다.  
VC1 : VC2의 인스턴스를 직접 생성하거나, 이미 생성되어 있는 인스턴스의 참조를 읽어온다.  
VC1 : 2번에서 정의된 VC2 인스턴스의 프로퍼티에 값을 대입한다.  
VC1에서 VC2로 화면전환을 한다.  
여러개의 데이터 값을 주고 받을 시에는 NSMutableDictionary 같은 집합 자료형을 사용하면 편리하다.  

### 이전 화면으로 값을 전달하기
현존하는 뷰 컨트롤러의 인스턴스의 참조값을 얻어온다.  
화면 전환 메소드 대신 복귀 메서드를 쓴다.  
이미 화면이 초기화 된 상태이므로, ViewDidLoad()메서드에 코드를 작성 하면 실행되지 않는다. 대신 화면을 보여질때 마다 실행되는 viewWiillAppear(_:)메서드에 작성한다.  
이전 화면으로 전달하는 값은 대부분 반영구적으로 저장해야 하는 값이 많기 때문에 동기 방식으로 전달하면 전달 값이 소실된다. (VC2 -> VC1 -> VC2 : 과정에서 VC2는 초기화됨)  

### 저장소를 사용하여 값을 주고 받기 (비동기)
뷰 컨트롤러들이 모두 접근할 수 있는 공용의 저장소를 이용하여 값을 저장한 후 이전 화면으로 복귀하면 이전 화면에서 적절한 시점에 저장소에 저장된 값을 읽어오는 방식을 구현한다.  
스크린에 다시 등장하는 시점에서 값을 읽어와야 하므로 viewWillAppear(_:)메서드에 읽어오는 소스를 삽입한다.  
가장 쉽게 쓰이는 방법은 앱이 종료되기 전까지 유지되는 AppDelegate.swift파일에 임시로 저장해 두는 방법이다.  
코코아 터치 프레임워크에서 제공하는 UserDefaults객체와 **코어 데이터(Core Data)**객체를 통해서 반영구적으로 데이터를 저장가능하다.  

### AppDelegate 객체를 사용하여 값을 주고받기
AppDelegate는 iOS 시스템에 의해서 앱 전체를 통틀어 하나의 인스턴스만 존재하도록 보장된다. 이를 Singleton(싱글톤) 이라고 하는데, 이 때문에 AppDelegate class는 직접생성할 수 없으며   UIApplication.shared.delegate 구문을 통해 생성되어 있는 객체를 참조해야 한다. 단, AppDelegate 객체는 앱의 생명주기와 함께 하므로 앱이 종료되면 데이터 역시 메모리에서 사라지게 된다.  

참조 ) 경우에 따라서는 AppDelegate를 대체할 클래스를 생성한다. 단, 아래 원칙을 지켜서 생성한다.  

UIResponse 클래스를 상속받아야 한다.  
UIApplicationDelegate 프로토콜 구현을 선언해야 한다  
@UIApplicationMain 어노테이션을 붙여주어야 한다.  

### UserDefaults 객체를 사용하여 값을 주고 받기
CocoaTouch FW에서 제공하는 UserDefaults 객체를 사용하여 값을 저장하면 앱이 삭제되기 전까지는 저장된 값이 유지된다.  
단순하면서도 값이 유지되어야 하는 로그인 여부, 간단한 설정 정보 등을 저장하는 경우가 많다.  
UserDefaults 객체의 인스턴스를 가져올때는 UserDefaults.standard 프로퍼티를 사용하며, 이 프로퍼티는 class 타입 프로퍼티이므로 인스턴스 생성없이 호출 가능하다.  
스위프트 기본 자료형을 그대로 저장할 수 있다.  
set(_:forKey:) 메소드를 사용하여 값을 저장하며, 저장된 key를 통해 구분이 된다.  

#### TIP
Action 인자값을 개별타입을 선택해야할 때  
   - 액션 메서드를 호출한 컨트롤의 속성값이 필요하거나, 이를 제어해야할 때  
​
Action 인자값을 AnyObject 타입을 선택해야 할때  
   - 서로 다른 타입의 컨트롤이 동일한 액션 메소드를 호출하게끔 처리하고 싶을 때  
   - 액션메서드를 호출한 컨트롤의 정보가 필요 없을 때  
   - 개별 타입을 반드시 사용해야 하는 경우를 제외한 나머지 경우  



## https://zeddios.tistory.com/310 (Zedd)
데이터 전달은 prepare나 IBAction이나.. 등등이 있음
~~~
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if segue.identifier == "segue name"{
        let PlaySoundVC = segue.destination as! PlaySoundsViewController
        PlaySoundVC.recordedAudioURL = recordedAudioURL
    }
}
~~~
근데 이렇게 두 VC의 상관관계가 깊어지고 디자인 모델이 구려짐 ㅡㅡ

.. 쭉 읽고 다시 생각해보니 델리게이트 이거도 결국 상관관계가 깊은거 아님?
 근데 어쨌든 뒤로 데이터 전달이 되네
 SendDataDelegate 라는 프로토콜로 하고,
 프로토콜 준수는 받는쪽이, 프로토콜 대리자는 보내는놈이 해야하는 특이한구조구려
 
으 그냥 Rx공부해서 실습 프로젝트 하나 만들어보죠 ㄲ
